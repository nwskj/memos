name: Build1

# 新增 push 触发：修改任意文件（含 YAML）都会触发构建；保留手动触发
on: 
  workflow_dispatch:  # 手动触发（原功能保留）
  push:               # 新增：推送代码（含 YAML 修改）自动触发
    branches: [ main ]  # 可选：限制仅 main 分支推送触发（可根据实际分支名修改）

jobs:
  build:
    runs-on: ubuntu-latest
    name: Build
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 'stable'
        check-latest: true

    - name: Set up Node.js（先不缓存 pnpm，避免依赖顺序问题）
      uses: actions/setup-node@v4
      with:
        node-version: 20
        # 暂时禁用 pnpm 缓存，先确保 pnpm 安装成功
        cache: ''

    - name: Install system dependencies (完整依赖集)
      run: |
        sudo apt update && sudo apt install -y \
          protobuf-compiler \
          jq \
          unzip \
          wget \
          git \
          curl \
          build-essential  # 补充编译依赖，避免 node-gyp 报错

    - name: 安装 pnpm 并配置环境（关键修复：提前安装并加入 PATH）
      run: |
        # 全局安装 pnpm，使用国内镜像加速
        npm install -g pnpm 
        # 验证 pnpm 安装成功并加入系统 PATH
        pnpm -v
        # 输出 pnpm 路径，确保后续步骤能找到
        echo "PNPM 路径：$(which pnpm)"
        # 将 pnpm 全局 bin 目录加入 PATH（避免后续命令找不到）
        echo "$(pnpm config get global-bin)" >> $GITHUB_PATH

    - name: Clone Repo & 初始化环境
      run: |
        # 克隆仓库并进入目录
        git clone https://github.com/Vespa314/cflow.git
        cd cflow
        # 验证 pnpm 可执行（二次确认）
        pnpm -v
        # 创建 proto 依赖目录（提前初始化，避免权限问题）
        mkdir -p ./proto/google/{api,protobuf}
        cd ..

    - name: Build Frontend (完整依赖+路径校验+版本锁定)
      run: |
        cd cflow
        # ==================== 1. 前端依赖安装（强制安装+版本锁定）====================
        cd web
        # 强制清理缓存并安装依赖，确保 protoc-gen-ts_proto 正确安装
        pnpm cache clean
        # 锁定 ts-proto 版本（避免兼容性问题）
        pnpm add ts-proto@1.169.0 --save-dev --registry=https://registry.npmmirror.com
        # 安装所有依赖（--force 确保依赖完整性）
        pnpm i --frozen-lockfile --force
        # 验证 node_modules 中是否存在 protoc-gen-ts_proto
        echo "验证 protoc-gen-ts_proto 插件存在性："
        ls -la ./node_modules/.bin/protoc-gen-ts_proto
        # 确保插件可执行
        chmod +x ./node_modules/.bin/protoc-gen-ts_proto
        cd ..
        
        # ==================== 2. 下载完整 Google Protobuf 依赖（含所有间接依赖）====================
        echo "下载 Google Protobuf 公共依赖（完整集合）..."
        # 标准 Protobuf 核心类型（补充更多可能用到的基础类型）
        wget -qO ./proto/google/protobuf/descriptor.proto https://raw.githubusercontent.com/protocolbuffers/protobuf/master/src/google/protobuf/descriptor.proto
        wget -qO ./proto/google/protobuf/empty.proto https://raw.githubusercontent.com/protocolbuffers/protobuf/master/src/google/protobuf/empty.proto
        wget -qO ./proto/google/protobuf/timestamp.proto https://raw.githubusercontent.com/protocolbuffers/protobuf/master/src/google/protobuf/timestamp.proto
        wget -qO ./proto/google/protobuf/field_mask.proto https://raw.githubusercontent.com/protocolbuffers/protobuf/master/src/google/protobuf/field_mask.proto
        wget -qO ./proto/google/protobuf/any.proto https://raw.githubusercontent.com/protocolbuffers/protobuf/master/src/google/protobuf/any.proto
        wget -qO ./proto/google/protobuf/struct.proto https://raw.githubusercontent.com/protocolbuffers/protobuf/master/src/google/protobuf/struct.proto
        # Google API 完整依赖（含所有可能的间接依赖）
        wget -qO ./proto/google/api/annotations.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/annotations.proto
        wget -qO ./proto/google/api/http.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/http.proto
        wget -qO ./proto/google/api/client.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/client.proto
        wget -qO ./proto/google/api/field_behavior.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/field_behavior.proto
        wget -qO ./proto/google/api/launch_stage.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/launch_stage.proto
        wget -qO ./proto/google/api/httpbody.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/httpbody.proto
        wget -qO ./proto/google/api/error_reason.proto https://raw.githubusercontent.com/googleapis/googleapis/master/google/api/error_reason.proto
        
        # 验证依赖文件是否下载成功
        DEPENDENCY_FILES=(
          "./proto/google/protobuf/descriptor.proto"
          "./proto/google/api/client.proto"
          "./proto/google/api/launch_stage.proto"
        )
        for file in "${DEPENDENCY_FILES[@]}"; do
          if [ ! -f "$file" ]; then
            echo "错误：依赖文件 $file 下载失败"
            exit 1
          fi
        done
        
        # ==================== 3. 查找并验证 proto 文件 ====================
        PROTO_FILES=$(find ./proto -name "*.proto" -path "*/api/v2/*")
        if [ -z "$PROTO_FILES" ]; then
          echo "警告：未找到 api/v2 目录下的 .proto 文件，尝试备用路径..."
          PROTO_FILES=$(find ./web/proto -name "*.proto" -path "*/api/v2/*")
        fi
        if [ -z "$PROTO_FILES" ]; then
          echo "错误：未找到任何 .proto 文件，无法生成类型文件"
          exit 1
        fi
        echo "找到的 proto 文件："
        echo "$PROTO_FILES"
        
        # ==================== 4. 生成 TypeScript 类型文件（路径修复+参数优化）====================
        echo "生成 TypeScript 类型文件..."
        # 直接使用绝对路径（避免相对路径问题）
        PLUGIN_PATH="$(cd ./web && pwd)/node_modules/.bin/protoc-gen-ts_proto"
        echo "使用插件路径：$PLUGIN_PATH"
        # 再次确保插件可执行
        chmod +x "$PLUGIN_PATH"
        
        # 执行 protoc 编译（使用绝对路径+完整参数，增加 --experimental_allow_proto3_optional 兼容 proto3 可选字段）
        protoc \
          --proto_path=./proto \
          --plugin=protoc-gen-ts_proto="$PLUGIN_PATH" \
          --ts_proto_out=./web/src/types/proto \
          --ts_proto_opt=esModuleInterop=true,forceLong=string,useOptionals=messages,outputTypeRegistry=true,exactTypes=false,useDate=true \
          --experimental_allow_proto3_optional \
          $PROTO_FILES
        
        # ==================== 5. 验证类型文件生成结果 ====================
        mkdir -p ./web/src/types/proto/api/v2
        GENERATED_FILES=$(ls ./web/src/types/proto/api/v2/*.ts 2>/dev/null | wc -l)
        if [ $GENERATED_FILES -eq 0 ]; then
          echo "错误：未生成任何 TypeScript 类型文件"
          echo "protoc 编译日志（如果有）："
          cat ./web/src/types/proto/*.log 2>/dev/null
          exit 1
        fi
        echo "成功生成 $GENERATED_FILES 个类型文件，目录结构："
        ls -la ./web/src/types/proto/api/v2/
        
        # ==================== 6. 前端编译（优化构建参数）====================
        cd web
        # 编译前清理旧产物
        rm -rf dist
        # 生产环境构建（禁用 sourcemap 加速构建，增加 --silent 减少输出噪音）
        pnpm build --mode production --sourcemap false --silent
        cd ..
        
        # ==================== 7. 复制前端产物（权限修复）====================
        mkdir -p ../artifact
        rm -rf ./server/router/frontend/dist
        mkdir -p ./server/router/frontend/dist
        # 复制产物并修复权限
        cp -R ./web/dist/* ./server/router/frontend/dist/
        chmod -R 755 ./server/router/frontend/dist
        cd ..

    - name: Build binary（优化编译流程）
      run: |
        cd cflow
        # 创建产物目录（避免目录不存在报错）
        mkdir -p artifact
        # 编译多架构二进制（优化命令顺序，避免重复清理，增加 -o 直接指定输出路径）
        # Windows-amd64
        GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -trimpath -ldflags="-w -s" -o artifact/cflow.exe ./cmd/cflow/main.go
        cd artifact && tar -czvf ../cflow-windows-amd64.tar.gz cflow.exe && cd ..
        # FreeBSD-amd64
        GOOS=freebsd GOARCH=amd64 CGO_ENABLED=0 go build -trimpath -ldflags="-w -s" -o artifact/cflow ./cmd/cflow/main.go
        cd artifact && tar -czvf ../cflow-freebsd-amd64.tar.gz cflow && cd ..
        # Darwin-amd64
        GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 go build -trimpath -ldflags="-w -s" -o artifact/cflow ./cmd/cflow/main.go
        cd artifact && tar -czvf ../cflow-darwin-amd64.tar.gz cflow && cd ..
        # Linux-amd64
        GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -trimpath -ldflags="-w -s" -o artifact/cflow ./cmd/cflow/main.go
        cd artifact && tar -czvf ../cflow-linux-amd64.tar.gz cflow && cd ..
        # Linux-arm64
        GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build -trimpath -ldflags="-w -s" -o artifact/cflow ./cmd/cflow/main.go
        cd artifact && tar -czvf ../cflow-linux-arm64.tar.gz cflow && cd ..
        # 清理临时文件
        rm -f artifact/cflow*
        cd ..
        
    - name: Upload artifact（稳定版本）
      uses: actions/upload-artifact@v4  # 使用稳定版 v4
      with:
        name: cflow-pre-built
        path: |
            cflow/cflow-windows-amd64.tar.gz
            cflow/cflow-freebsd-amd64.tar.gz
            cflow/cflow-darwin-amd64.tar.gz
            cflow/cflow-linux-amd64.tar.gz
            cflow/cflow-linux-arm64.tar.gz
        retention-days: 3  # 保留 3 天，避免存储占用
        
    - name: Generate release tag（兼容无标签+错误处理）
      id: tag
      run: |
        # 增加超时和错误处理，使用 curl 替代 wget（兼容性更好）
        LATEST_TAG=$(curl -s -m 10 https://api.github.com/repos/Vespa314/cflow/tags | jq -r '.[0].name // "v1.0.0"' | sed 's/^v//')
        if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" == "null" ]; then
          LATEST_TAG="1.0.0"
        fi
        echo "release_tag=v$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "最终发布标签：v$LATEST_TAG"

    - name: Delete existing tag (if exists)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TAG_NAME: ${{ steps.tag.outputs.release_tag }}
      run: |
        cd cflow
        git config --global user.email "action@github.com"
        git config --global user.name "GitHub Action"
        # 验证仓库是否为 git 仓库
        if [ ! -d .git ]; then
          echo "警告：当前目录不是 git 仓库，跳过标签删除"
          exit 0
        fi
        # 拉取所有标签（确保能找到远程标签）
        git fetch --tags
        # 删除本地标签
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          git tag -d "$TAG_NAME"
          echo "删除本地标签 $TAG_NAME"
        fi
        # 删除远程标签（忽略不存在的错误）
        git push origin --delete "$TAG_NAME" 2>/dev/null || echo "远程标签 $TAG_NAME 不存在"
        cd ..

    - name: Create release（稳定版+重试机制）
      uses: softprops/action-gh-release@v2  # 使用最新稳定版 v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.release_tag }}
        files: |
            cflow/cflow-windows-amd64.tar.gz
            cflow/cflow-freebsd-amd64.tar.gz
            cflow/cflow-darwin-amd64.tar.gz
            cflow/cflow-linux-amd64.tar.gz
            cflow/cflow-linux-arm64.tar.gz
        overwrite: true
        draft: false
        prerelease: false
        fail_on_unmatched_files: false  # 忽略文件不匹配错误

    - name: Delete workflow runs（可选优化）
      if: always()  # 无论前面步骤是否成功都执行
      uses: Mattraks/delete-workflow-runs@v2
      with:
        token: ${{ github.token }}
        repository: ${{ github.repository }}
        retain_days: 1
        keep_minimum_runs: 8
